
因为表达式太长了，在这里展开一下
root >> rotation >> x
q.movement_direction(0) q.movement_direction(2) // 运动方向 只需要xz，用来计算运动速度在实体朝向的投影
q.body_y_rotation // 如果在 actor 上调用，则返回身体偏转旋转，否则返回 0.0。  用来计算实体朝向（水平）

#### 关键计算

```js
// 判断实体运动方向与朝向的关系，倒车为-1，前进为1
// 因为动画坐标系与世界坐标系不同，z轴要乘-1，下同
const TEMP_1_1 = (math.abs(q.body_y_rotation - math.atan2(v.dir_x, -v.dir_z)) > 90 ? -1 : 1)

// 速度与水平面的夹角
const TEMP_1_2 = -math.atan2(q.vertical_speed, q.ground_speed)

// 水平速度较大时的俯仰角，区分前进和后退
const TEMP_1 = TEMP_1_1 * TEMP_1_2

// 限制俯仰角，并且竖直速度较小时，只偏转比较小的角度
const TEMP_2 = math.min(0.7, math.abs(query.vertical_speed/11))

// 实体速度与朝向的夹角的余弦值 当运动方向与实体朝向不重合时，减小旋转角度
const TEMP_3 = math.abs(math.cos(q.body_y_rotation - math.atan2(v.dir_x, -v.dir_z)))

// 平速度较小时的俯仰角，此时不分前进和后退，均是上升时后脚在下，下降时前脚在下
const TEMP_4 = math.min(math.max(q.vertical_speed*-5, -60), 60)

// 最终结果，计算实体的俯仰角
const RESULT = (v.dir_x+v.dir_z) < 0.1 ? math.min(math.max(q.vertical_speed*-5, -60), 60) : (math.abs(q.body_y_rotation - math.atan2(v.dir_x, -v.dir_z)) > 90 ? -1 : 1) * -math.atan2(q.vertical_speed, q.ground_speed) * math.min(0.7, math.abs(query.vertical_speed/11)) * math.abs(math.cos(q.body_y_rotation - math.atan2(v.dir_x, -v.dir_z)))
```

(v.dir_x+v.dir_z) < 0.1 ? EMP_4 : TEMP_1 * TEMP_2 * TEMP_3

需要在script搞一下速度过渡
ground speed也有问题，是算上竖直方向的，所以水平速度要另算

另外几个骨骼的旋转都是为了修复原版跳起后会保持双足站立的问题，在驯服状态忽略站立的角度。